# **Project Context **

## **Purpose**

The **Payment Microservices Platform** aims to provide a lightweight, modular, and scalable payment service built with an API-first approach.
The project handles the full lifecycle of a payment, including:

* creating a payment,
* retrieving payment details,
* updating payment status,
* storing data using Spring Data JPA with an H2 database.

All REST endpoints and DTOs are defined using **OpenAPI (OpenSpec)** and generated automatically using **Codex**, ensuring strong contract consistency and minimal boilerplate.

The goal is to create a clean, extensible foundation that can evolve into a full microservice ecosystem (billing, notifications, external payment gateways, etc.).

---

## **Tech Stack**

* **Java 17** (minimum required for Spring Boot 3.5.7)
* **Spring Boot 3**

    * Spring Web
    * Spring Data JPA
    * Spring Validation
* **H2 Database** (in-memory or file mode)
* **Lombok**
* **OpenAPI 3 (OpenSpec)** for contract-first development
* **Codex / OpenAPI Generator** for code generation
* **Maven** as the build tool

---

## **Project Conventions**

### **Code Style**

* Follow standard **Spring Boot coding conventions**
* Use Lombok to reduce boilerplate (`@Getter`, `@Setter`, `@Builder`, `@Data`, etc.)
* Do **not** manually modify generated DTOs or API interfaces
* Naming conventions:

    * Classes → PascalCase
    * Variables & methods → camelCase
    * API endpoints → kebab-case (`/payments/{id}/status`)
* Use meaningful package structure:

```
com.asma.paymentservice
 ├── controller
 ├── service
 ├── repository
 ├── entity
 ├── dto          (generated by Codex)
 ├── config
 └── exception
```

---

### **Architecture Patterns**

* API-first microservice architecture
* **OpenAPI-driven development**:

    * REST controllers, DTOs, and interface contracts are generated
* **Service layer** contains business logic
* **Repository layer** interacts with H2 using Spring Data JPA
* Clean separation between:

    * Controller
    * Service
    * Repository
    * Domain model

Designed so the project can easily scale later (PostgreSQL, Kafka, distributed architecture).

---

### **Testing Strategy**

* **Unit tests** using JUnit 5
* **Integration tests** using H2
* **Contract tests** based on OpenAPI spec
* Goals:

    * Ensure strict adherence to API contracts
    * Achieve high service-level coverage
    * Keep test execution fast and deterministic

---

### **Git Workflow**

* Use a simple and effective branching model:

    * `main` → stable production-ready code
    * `feature/*` → development of new features
* Commit messages follow **Conventional Commits**:

    * `feat: add create payment endpoint`
    * `fix: correct status validation`
    * `refactor: clean service logic`
    * `docs: update OpenAPI spec`
* Pull Requests required before merging into `main`.

---

## **Domain Context**

Domain object: **Payment**

A payment contains:

* `id`
* `amount`
* `currency`
* `method`
* `status`
* `userId`
* `createdAt`
* `updatedAt`

Valid statuses:

* `PENDING`
* `APPROVED`
* `FAILED`
* `CANCELED`

Business rules:

* Status transitions must follow controlled logic
* The Payment Service is isolated for now, but designed to integrate later with:

    * Billing Service
    * Notification Service
    * External payment gateways (Stripe, PayPal, etc.)

---

## **Important Constraints**

* **The OpenAPI spec is the source of truth**
* DTOs and controllers generated by Codex **must not** be edited manually
* H2 is used for development only
* JPA entities must remain simple and clean
* Ensure no sensitive information is logged
* Must stay extensible for future adoption of PostgreSQL / Kafka / microservice separation

---

## **External Dependencies**

* **OpenSpec / Codex** for code generation
* **Lombok** for boilerplate reduction
* **Spring Boot Starter Web & Data JPA**
* **H2 database**
* (Future optional integrations)

    * Stripe or PayPal APIs
    * Kafka or RabbitMQ
    * API Gateway